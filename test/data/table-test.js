// Generated by CoffeeScript 1.6.3
(function() {
  var Schema, Table, assert, checks, coltests, makeTable, rowtests, suite, vows;

  require("../env");

  vows = require("vows");

  assert = require("assert");

  suite = vows.describe("table.js");

  Table = data.Table;

  Schema = data.Schema;

  makeTable = function(n, type) {
    var rows;
    if (n == null) {
      n = 10;
    }
    if (type == null) {
      type = "row";
    }
    rows = _.times(10, function(i) {
      return {
        a: i % 2,
        b: "" + i,
        x: i,
        y: {
          z: i
        }
      };
    });
    return Table.fromArray(rows, null, type);
  };

  checks = {
    "cached": {
      topic: function(t) {
        return t.cache();
      },
      "has 10 rows": function(t) {
        return assert.equal(t.nrows(), 10);
      }
    },
    "filter x < 4": {
      topic: function(t) {
        return t.filter(function(row) {
          return row.get('x') < 4;
        });
      },
      "has 4 rows": function(t) {
        return assert.equal(t.nrows(), 4);
      }
    },
    "partition on a": {
      topic: function(t) {
        return t.partition(['a']);
      },
      "has 2 rows": function(t) {
        return assert.equal(t.nrows(), 2);
      },
      "single function aggregate c=count(x), s=sum(x)": {
        topic: function(t) {
          return t.aggregate([
            {
              alias: ['c', 's'],
              f: function(t) {
                var vals;
                vals = t.all('x');
                return {
                  c: vals.length,
                  s: _.reduce(vals, (function(a, b) {
                    return a + b;
                  }), 0)
                };
              },
              type: data.Schema.numeric
            }
          ]);
        },
        "is correct": function(t) {
          return t.each(function(row) {
            assert.equal(row.get('s'), row.get('a') * 5 + 20);
            return assert.equal(row.get('c'), 5);
          });
        }
      },
      "multi function aggregate c=count(x), s=sum(x)": {
        topic: function(t) {
          return t.aggregate([data.ops.Aggregate.count('c'), data.ops.Aggregate.sum('s', 'x')]);
        },
        "is correct": function(t) {
          return t.each(function(row) {
            assert.equal(row.get('s'), row.get('a') * 5 + 20);
            return assert.equal(row.get('c'), 5);
          });
        }
      }
    },
    "union with itself": {
      topic: function(t) {
        return t.union(t);
      },
      "has 20 rows": function(t) {
        return assert.equal(t.nrows(), 20);
      }
    },
    "union with itself 5 times as array": {
      topic: function(t) {
        return t.union(_.times(5, function() {
          return t;
        }));
      },
      "has 60 rows": function(t) {
        return assert.equal(t.nrows(), 60);
      }
    },
    "union with itself 5 times as args": {
      topic: function(t) {
        return t.union(t, t, t, t, t);
      },
      "has 60 rows": function(t) {
        return assert.equal(t.nrows(), 60);
      }
    },
    "limit 2": {
      topic: function(t) {
        return t.limit(2);
      },
      "has 2 rows": function(t) {
        assert.equal(t.nrows(), 2);
        return t.each(function(row) {
          return assert.lt(row.get('x'), 3);
        });
      }
    },
    "offset 5 limit 2": {
      topic: function(t) {
        return t.offset(5).limit(2);
      },
      "has 2 rows": function(t) {
        return assert.equal(t.nrows(), 2);
      },
      "5 <= x < 7": function(t) {
        return t.each(function(row) {
          assert.lte(5, row.get('x'));
          return assert.lt(row.get('x'), 7);
        });
      }
    },
    "other table  { x: i+5, t: i%3}": {
      topic: function(t) {
        var rows, t2;
        rows = _.times(10, function(i) {
          return {
            x: i + 5,
            b: i % 3
          };
        });
        t2 = data.Table.fromArray(rows);
        return [t, t2];
      },
      "cross product via .cross()": {
        topic: function(_arg) {
          var t1, t2;
          t1 = _arg[0], t2 = _arg[1];
          return t1.cross(t2);
        },
        "has 100 rows": function(t) {
          return assert.equal(t.nrows(), 100);
        }
      },
      "cross product via join": {
        topic: function(_arg) {
          var t1, t2;
          t1 = _arg[0], t2 = _arg[1];
          return t1.join(t2, []);
        },
        "has 100 rows": function(t) {
          return assert.equal(t.nrows(), 100);
        }
      },
      "outer join on x": {
        topic: function(_arg) {
          var t1, t2;
          t1 = _arg[0], t2 = _arg[1];
          return t1.join(t2, ['x']);
        },
        "has 15 rows": function(t) {
          return assert.equal(t.nrows(), 15);
        }
      },
      "left join on x": {
        topic: function(_arg) {
          var t1, t2;
          t1 = _arg[0], t2 = _arg[1];
          return t1.join(t2, ['x'], "left");
        },
        "has 10 rows": function(t) {
          return assert.equal(t.nrows(), 10);
        }
      },
      "right join on x": {
        topic: function(_arg) {
          var t1, t2;
          t1 = _arg[0], t2 = _arg[1];
          return t1.join(t2, ['x'], "right");
        },
        "has 10 rows": function(t) {
          return assert.equal(t.nrows(), 10);
        }
      },
      "inner join on x": {
        topic: function(_arg) {
          var t1, t2;
          t1 = _arg[0], t2 = _arg[1];
          return t1.join(t2, ['x'], "inner");
        },
        "has 5 rows": function(t) {
          return assert.equal(t.nrows(), 5);
        }
      }
    },
    "project not extend": {
      topic: function(t) {
        return t.project([
          'x', {
            alias: 'y',
            f: function(x) {
              return x + 100;
            },
            cols: 'x',
            type: data.Schema.numeric
          }, {
            alias: 'z',
            f: function(row) {
              return row.get('x') * 100;
            },
            cols: '*',
            type: data.Schema.numeric
          }, {
            alias: ['n', 'm'],
            f: function(x) {
              return {
                n: -x,
                m: -x - 1000
              };
            },
            type: data.Schema.numeric,
            cols: 'x'
          }
        ], false);
      },
      "values correct": function(t) {
        return t.each(function(row) {
          var x;
          x = row.get('x');
          assert.equal(row.get('a'), null);
          assert.equal(row.get('y'), x + 100, "y is wrong " + (row.get('y')) + " != " + (x + 100));
          assert.equal(row.get('z'), x * 100, "z is wrong " + (row.get('z')) + " != " + (x * 100));
          assert.equal(row.get('n'), -x, "n is wrong " + (row.get('n')) + " != " + (-x));
          return assert.equal(row.get('m'), -x - 1000, "m is wrong " + (row.get('m')) + " != " + (-x - 1000));
        });
      }
    },
    "project and extend": {
      topic: function(t) {
        return t.project([
          'x', {
            alias: 'y',
            f: function(x) {
              return x + 100;
            },
            cols: 'x',
            type: data.Schema.numeric
          }, {
            alias: 'z',
            f: function(row) {
              return row.get('x') * 100;
            },
            cols: '*',
            type: data.Schema.numeric
          }, {
            alias: ['n', 'm'],
            f: function(x) {
              return {
                n: -x,
                m: -x - 1000
              };
            },
            type: data.Schema.numeric,
            cols: 'x'
          }
        ], true);
      },
      "values correct": function(t) {
        return t.each(function(row) {
          var x;
          x = row.get('x');
          assert.equal(row.get('a'), x % 2);
          assert.equal(row.get('y'), x + 100, "y is wrong " + (row.get('y')) + " != " + (x + 100));
          assert.equal(row.get('z'), x * 100, "z is wrong " + (row.get('z')) + " != " + (x * 100));
          assert.equal(row.get('n'), -x, "n is wrong " + (row.get('n')) + " != " + (-x));
          return assert.equal(row.get('m'), -x - 1000, "m is wrong " + (row.get('m')) + " != " + (-x - 1000));
        });
      }
    },
    "can be turned to json and parsed back": function(t) {
      var json, rows1, rows2, t2;
      json = t.toJSON();
      t2 = data.Table.fromJSON(json);
      assert.deepEqual(t.schema.toJSON(), t2.schema.toJSON());
      rows1 = t.all();
      rows2 = t2.all();
      return _.each(_.zip(rows1, rows2), function(_arg) {
        var r1, r2;
        r1 = _arg[0], r2 = _arg[1];
        return assert.equal(r1.get('a'), r2.get('a'), "a's should be equal: " + (r1.get('a')) + " != " + (r2.get('a')));
      });
    }
  };

  rowtests = {
    topic: makeTable
  };

  _.extend(rowtests, checks);

  coltests = {
    topic: function() {
      return makeTable(10, 'col');
    }
  };

  _.extend(coltests, checks);

  suite.addBatch({
    "rowtable": rowtests,
    "coltable": coltests,
    "emptytable": {
      topic: function() {
        return new data.RowTable(new data.Schema(['x'], [data.Schema.unknown]));
      },
      "when unioned with itself": {
        topic: function(t) {
          return t.union(t);
        },
        "works": function(t) {
          return assert.equal(t.nrows(), 0);
        }
      },
      "whith empty union": {
        topic: function(t) {
          return new data.ops.Union([t, t]);
        },
        works: function(t) {
          return assert.equal(t.nrows(), 0);
        }
      }
    }
  });

  suite["export"](module);

}).call(this);
